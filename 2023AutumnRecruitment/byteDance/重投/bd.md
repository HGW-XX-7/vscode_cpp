**题1**
查询子串出现了多少次，请注意，小红会询问多次。
输入描述
第一行输入两个正整数$n$和$q$，代表字符串长度和询问次数。
第二行输入一行长度为$n$的，仅由小写英文字母组成的字符串。代表小红拿到的字符串。
接下来的q行，每行输入一个仅由小写英文字母组成的字符串，代涯谛帏翟常罢艾雕撑化红的每次查询。
$1 <=n, q<= 10^5$
每次查询的字符串长度不超过 10
输出描述
输出$q$行，每行输出一个整数，代表该次查询的结果
输入
```
10 3
bobobalice
bob
alice
red
```

输出
```
2
1
0
```

**题2**
小红有两个长度为n的数组，分别为a和。她可以先选择一个实数mul，获得c数组，其中
c_i=mul*a_i+b_i，小红想知道，她能获得的数组 c，最多有几个 0。
输入：
一行一个数字n，表示数组长度。一行n个正整数a_i表示数组a。一行n个正整数b_i，表示数组b。
输出：一个正整数，表示有几个0。
示例：
输入
```
4
2 4 6 7 
1 2 3 4
```
输出
```
3
```
说明：选择mul=-0.5，则c=[0,0,0,5]，有三个0.

其中一种可能的cpp代码是：（同时为了保证精度，写一个分子分母的数据结构，支持约分（记得检验分母为0的情况），判定相等，判定小于的操作；用map<实数，int>去维护每个实数的个数）

a[i] = b[i] = 0的情况 int应该全部换成long long

**题3**
使用cpp解决这个问题：
小红拿到了3个数组，她准备各取一个前缀(前缀的长度可以是0)，总共取k个数。小红希望最终这k个数的按位或尽可能大。请你帮帮小红。
注:按位或指二进制上每一位取或运算，例如3的进制表示是(0011)，9的二进制表示是(1001)，那么
3 or 9=(1010)2=11
示例1：
输入
```
4 2 
1 2 3 4
2 2 3 4
4 2 3 4
```
输出
```
6
```
示例2
输入
```
4 4
1 2 3 4
2 2 3 4
4 2 3 4
```
输出
```
7
```
部分代码实现可以是：
```cpp
int func(vector<vector<int>> array){
//求前缀
vector<int> prf[3];
for(i =0;i<3;++i){
  prf[0][i]=array[j][i]
  for(int j =1; j < array[i].size();++j)
    prf[j]=array[j-1][i] | prf[j];
}
//
vector<pair<int,int>> pO[3];
for(i 0-3){
pO[i]={make_pair(0, prf[i][0])}; //重要：这里的po就是在缩减长度 把原本1e5的数组缩小到32
for(int j=0; j < prf[i].size()-1;++j){
  if(a[j]!=a[j+1]){
    x.push_back(make_pair(j+1,a[j+1]));
}
enum(i,j,k)
}
}
enum：
for(i 0-po0.size)
 for j 0-po1.size
  for k 0-po2.size{
int x1=poi0.first,x2=poi1.second;
```
y和z同理;
```cpp
if(x1+y1+z1+3<=k){
  计算答案tmpans = x2|y2|z2
  if(countOnes(tmpans)>countOnes(ans)) 
    ans = tmpans
}
```
对于每个数组，计算前缀或；对每个数组的前缀数组{(a,b)}进行维护，其中b代表前缀或，a代表它第一次出现的位置。假设前缀或是1,11,11,111,111 那么这个数组应该是(0,1) (1, 11)(3,111)；
如果有前缀或数组a，那么计算x的方式是：（注意，是对三个数组分别求一个prefix）
```cpp
x={make_pair(0, a[0])};
for(int i=0; i < a.size()-1;++i){
  if(a[i]!=a[i+1]){
    x.push_back(make_pair(i+1,a[i]));
}
}
```
那么你只需要枚举i j k，假设对三个数组操作之后得到的数组是x y z，那么计算答案就是伪代码：if(i+j+k+3<K){ans=maxcount1(ans, xi | yi | zi);}；
注意：maxcount1就是计算两个数哪个1多；有部分实现可以写成伪代码：

```cpp
for(int i =0; i<x.size;++i)
  for(j...)
    for(k...)
      if(i+j+k+3<=K){
        ans=maxcount1(ans, xi | yi | zi);else break;
      }
```

注意：伪代码：if(x1+y1+z1+3<=k)表示取这么长，并且不多于k个的前缀之后，计算答案tmpans = x2|y2|z2，if(countOnes(tmpans)>countOnes(ans)) ans = tmpans，最后输出countOnes(tmp)

**题4**
用cpp解决这个问题：
小红有两个字符串s和t，每次可以对s分成s=s1+s2然后拼接成新的字符串 s2+s1。例如字符串“abcd”可以分割成“ab”和“cd”，然后拼接成"cdab"；
小红想知道恰好进行k次操作，将s变成t的方案数，输出方案数模10^9+7的结果。
注意，分割的两个字符串都不能是空串。
输入：第一行一个仅包含小写字母的字符串s，第二行一个仅包含小写字母的字符串t，第三行一个正整数k。
输出一个整数表示答案。
示例：
输入
```
abcde
cdeab
2
```
输出
```
3
```