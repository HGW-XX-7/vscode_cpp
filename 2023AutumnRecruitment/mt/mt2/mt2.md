#### 题1：

美团商家的订单发起时，订单编号最开始从1开始，后续每发起一个订单，订单编号便在上一订单编号的基础上+1。为了防止订单号过大，商家还可以设置一个编号上限m，当订单编号超过m时，将又从1开始编号。
小美想知道，当订单编号上限为m时，第x个订单编号是多少?将有q次询问。
输入描述：
第一行输入一个整数$q(1≤q≤50000)$
接下来q行，每行两个整数$m,x(1≤m,x≤〖10〗^9)$。
输出描述：q行，每行一个整数表示答案
用例1：
输入：
```cpp
4
2 3
5 17
8 2
4 4
```

输出：
```cpp
1
2
2
4
```
#### 题2
有一个长度为 n 的数组，将这个数组进行求和，即$sum =a_1 +a_2+...+a_n$ 。可以使用一次魔法 (也可以不使用) ，将其中一个加号变成乘号，使得sum最大。求出最大的 sum。
输入描述：第一行输入一个整数n。第二行输入n个整数表示数组a。$1≤n≤10^5$；$1≤a_i≤10^9$
输出描述：输出一个整数表示答案。6 1 1 4 5 1 4 
对于用例6 1 1 4 5 1 4。应该输出27，因为可以将4和5之间的加号改成乘号1+1+4*5+1+4=27。

定义一个01 串的权值为: 每次操作选择一位取反，使得相邻字符都不相等的最小操作次数。
例如，“10001”的权值是 1，因为只需要修改一次: 对第三个字符取反即可。
现在小美拿到了一个 01 串，她希望你求出所有非空连续子串的权值之和，你能帮帮她吗?
输入描述：一个仅包含0和1的字符串，长度不超过 2000。
输出描述：所有非空子串的权值和。

测试用例：输入10001，输出8。测试用例说明：长度为2的子串中，有2个“00”的权值是 1。长度为3的3个子串权值都是1。长度为4的2个子串权值都是 1。长度为5的1个子串权值是 1。总权值之和为2+3+2+1=8

思路：
维护两个前缀数组，`pref[i]`表示前i个数字变成010101...所需的改动次数 `pref2`对应的是101010...
那么将[a,b]串改动的次数最小值是`min(pref1b-pref1a,pref2b-prf2a)`
布尔值的true可以强制类型转换成1 
`pref1i=pref1[i-1]+(i%2!=a[i])`

#### 题3

我拿到了一个数组，我每次可以进行如下操作:
选择两个元素，一个加 1，另一个减 1。
我希望若干次操作后，众数的出现次数尽可能多。你能帮我求出最小的操作次数吗?
众数定义:在一组数据中，出现次数最多的数据，是一组数据中的原数据，而不是相应的次数。一组数据中的众数不止一个，如数据2、3、-1、2、1、3中，2、3都出现了两次，它们都是这组数据中的众数。
输入描述：第一行为一个正整数n，代表数组的大小。第二行输入n个正整数ai，代表小美拿到的数组。输出描述：一个整数，代表最小的操作次数。

测试用例1：输入：3 1 4 4；应该输出2。说明：第一次操作:第一个数加1，第二个数减 1。第二次操作:第一个数加 1,第三个数减 1。数组变成[3,3,3]，众数出现了 3 次。所以共操作2次。
测试用例2：输入3 1 5 5；输出0。说明：众数出现了2次，由于无法再用操作使得众数出现的次数变得更多，所以无需操作。